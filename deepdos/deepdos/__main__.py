"""
    The main functionality of deepdos
"""
import os

from deepdos.args import parse_args
from deepdos.conf import ETC_DIR, create_logger, load_conf, HEADERSIZE, SERVER_IP, SERVER_PORT
from deepdos.data import load_model, parse_flow_data
from deepdos.utils.network import create_firewall, examine_flow_packets
from deepdos.utils.processes import (proc_capture_pcap,
                                     proc_execute_cicflowmeter)
from deepdos.utils.TCPClient import TCPClient
import ipaddress

class DeepDos:
    """
        The Deepdos executor and class manager
    """

    def __init__(self, options: dict):
        # Init data
        self.running = True
        self.model = load_model(options["model_type"])
        self.interface = options["interface"]
        self.interface_data = options["interface_data"]
        self.ip_v4 = self.interface_data["2"]["address"]
        self.active_firewall = options["firewall"]
        self.logger = create_logger(__name__, options["log"])

        # Predictions file
        self.flow_file = open(f"{ETC_DIR}/logs/flow_file.txt", "w+")

        # Setup the firewall
        if self.active_firewall:
            self.firewall = create_firewall(
                self.interface,
                self.interface_data,
                self.active_firewall,
                options["naughty_count"],
            )

            if not self.firewall:
                self.logger.info("Need to be root in order to create the Firewall")
        else:
            self.firewall = None

    def capture_network_data(self):
        """
            Write pcap data
        """
        pcap_file = open(f"{ETC_DIR}/pcap_info/out.pcap", "w", encoding="ISO-8859-1")
        pcap_list = proc_capture_pcap(self.interface)

        # The counter controls the amount of writes that occur.
        self.logger.info("Writing packet data to out.pcap file")
        pcap_file.writelines(pcap_list)
        pcap_file.close()

        # Execute cicflowmeter
        self.logger.info("Generating CSV from out.pcap")
        proc_execute_cicflowmeter(ETC_DIR)

    def evaluate_network_data(self):
        """
            Load the flow data generated by the cicflowmeter, classify the flow data,
            and then take action with the firewall if needed.

            Returns:
                The output logs of examining the flow packets
        """
        try:
            # Parse the flow data
            flow_data = parse_flow_data()
        except ValueError:
            raise ValueError("too little flow")
        """
        # Grab data out of model processor
        flow_features = flow_data["data"]
        flow_metadata = flow_data["metadata"]

        # Run model predictions
        result = self.model.predict(flow_features)
        proba = self.model.predict_proba(flow_features)

        # Flag Ip flow
        result_data = flow_metadata, result, proba
        malicious_flows, flow_logs = examine_flow_packets(result_data, self.ip_v4)

        # If there is an active firewall, track all malicious flows
        if self.firewall:
            self.firewall.track_flows(malicious_flows)
        return flow_logs
        """
        if flow_data.size == 0:
            return None
            
        result = self.model.predict(flow_data)
        proba = self.model.predict_proba(flow_data)
        
        #send only malicious packet info
        mal_result = []
        mal_flow = []
        mal_proba = []

        for res, prob, flow in zip(result, proba, flow_data):
            if res != 0:
                mal_result.append(res)
                flow[0] = str(ipaddress.ip_address(flow[0]))
                flow[2] = str(ipaddress.ip_address(flow[2]))
                mal_flow.append(flow)
                mal_proba.append(prob)

        if not mal_result:
            return None

        # Print and log the attack
        self.log_format(mal_result, mal_flow, mal_proba)

        # data to ips
        obj2send = {"mal_result": mal_result, "mal_flow": mal_flow, "mal_proba": mal_proba}
        return obj2send

    def log_format(self, mal_result, mal_flow, mal_proba):
        attack_dict = {0: "BENIGN", 1: "LDAP", 2: "MSSQL", 3: "NetBIOS", 4: "Portmap", 5: "Syn", 6: "UDP", 7: "UDPLag"}
        for res, flow, prob in zip(mal_result, mal_flow, mal_proba):
            temp = "From " + flow[0] + ":" + str(flow[1]) + " to " + flow[2] + ":" + str(flow[3]) + " -> Attack Type: " + str(attack_dict[res]) + " with probability: " + str(prob[res])
            self.logger.info(temp)
            print(temp)


    def main_loop(self):
        """
            Enter the main loop of the program, executing the sub processes
            and executing model commands
        """
        # Execute the main loop
        while self.running:
            try:                
                # Capture network data and then evaluate it
                self.capture_network_data()
                obj2send = self.evaluate_network_data()
                if obj2send:
                    myclient = TCPClient(HEADERSIZE, SERVER_IP, SERVER_PORT)
                    myclient.send2server(obj2send)

                # remove the old pcap file
                os.remove(f"{ETC_DIR}/pcap_info/out.pcap")

            except ValueError as exception:
                # Handle flow error
                if exception.args[0] == "too little flow":
                    self.logger.warning("Not enough flow generated, restarting process")


def start_execution():
    """
        Parse arguments and run our deepdos application
    """
    # Parse all options for deepdos
    options = parse_args()
    # Instantiate logging

    # Load config file
    load_conf()

    # Execute deepdos mainloop
    DeepDos(options).main_loop()


if __name__ == "__main__":

    start_execution()
